# item09 不在构造和析构过程中调用虚函数
因为基类的构造/析构函数不会将虚函数的调用下降到派生类重载的虚函数，这么做的理由是显然的，首先对于构造函数，因为基类先于派生类构造，所以不能去使用尚未准备好的资源；其次对于析构函数，因为派生类先于基类析构，所以不能去使用已经被销毁的资源。至于为什么“基类的构造/析构函数不会将虚函数的调用下降到派生类重载的虚函数”，是因为构造函数一定是将虚表指针设置成自己的虚表地址，析构函数又会恢复虚表指针，参见[《C++反汇编与逆向分析技术》笔记](https://github.com/l-iberty/Disassembly-And-RE-For-Cpp)。